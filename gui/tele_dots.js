// Title: Teleporting Dots
// Author: FAL
// Date: 18. Oct. 2017
// Made with p5.js v0.5.16
// Generated by TypeScript v2.5.3 + manually edited

"use strict";
const IDEAL_FRAME_RATE = 60;
const UNIT_ANGLE_VELOCITY = (2 * Math.PI) / IDEAL_FRAME_RATE;

p5.disableFriendlyErrors = true;
const particleSet = [];
let largeSphereRadius;
let alternativeViewIsOn = false;
function getAirCurrentDirection(position) {
    const noiseOffset = 0.003 * frameCount;
    const angleOffset = 0.1 * (frameCount / IDEAL_FRAME_RATE) * TWO_PI;
    return (noise(noiseOffset) * TWO_PI) + angleOffset;
}
function applyAirCurrentForceField(particle) {
    const position = particle.position;
    const directionAngle = getAirCurrentDirection(position);
    const speed = radians(1);
    const latitudeDisplacement = speed * Math.cos(directionAngle);
    const longitudeDisplacement = speed * Math.sin(directionAngle);
    particle.position.set(position.latitude + latitudeDisplacement, position.longitude + longitudeDisplacement);
}
class Particle {
    constructor() {
        this.position = new GeographicPosition();
        this.positionHistory = new PositionHistory(7 /* capacity */, createVector);
        this.displaySize = 3;
    }
    display() {
        let sizeFactor = (this.positionHistory.capacity - this.positionHistory.validHistoryCount + 1)
            / (this.positionHistory.capacity + 1);
        for (const pos of this.positionHistory) {
            push();
            translate(pos.x, pos.y, pos.z);
            sphere(sizeFactor * this.displaySize, 6, 4);
            pop();
            sizeFactor += 1 / (this.positionHistory.capacity + 1);
        }
        push();
        translate(this.position.x, this.position.y, this.position.z);
        sphere(this.displaySize, 6, 4);
        pop();
        if (frameCount % 2 === 0)
            this.positionHistory.push(this.position);
    }
}
function setup() {
    const canvasSideLength = Math.max(Math.min(windowWidth, windowHeight) * 0.95, Math.min(displayWidth, displayHeight) * 0.5);
    createCanvas(canvasSideLength, canvasSideLength, WEBGL);
    frameRate(IDEAL_FRAME_RATE);
    const scaleFactor = canvasSideLength / 640;
    largeSphereRadius = 240 * scaleFactor;
    for (let i = 0; i < 64; i += 1) {
        const newParticle = new Particle();
        newParticle.position.set(Math.random() * 2 * Math.PI, Math.random() * 2 * Math.PI, largeSphereRadius);
        newParticle.displaySize = 4 * scaleFactor;
        particleSet.push(newParticle);
    }
};
function draw() {
    if (alternativeViewIsOn) {
        background(16);
        noStroke();
        fill(255, 64, 128);
    }
    else {
        background(248);
        noStroke();
        fill(128, 128, 255);
    }
    for (const eachParticle of particleSet) {
        applyAirCurrentForceField(eachParticle);
        eachParticle.display();
    }
};
function mousePressed() {
    alternativeViewIsOn = true;
};
function mouseReleased() {
    alternativeViewIsOn = false;
};